;|*************************************************************;
软件作者: Highflybird                                          ;
软件用途: 为AutoCAD 的LISP定制的一些算法和函数(FFT算法)        ;
日期地点: 2022.07.08 深圳                                      ;
程序语言: AutoLISP,Visual LISP                                 ;
版本号:   Ver. 1.0.22.0708                                     ;
===============================================================;
================================================================
本软件为开源软件: 以下是开源申明:                               
----------------------------------------------------------------
本页面的软件遵照 GPL协议开放源代码，您可以自由传播和修改，在遵照
下面的约束条件的前提下:                                         
                                                                
一. 只要你在本开源软件的每一副本上明显和恰当地出版版权声明，保持
    此许可证的声明和没有担保的声明完整无损，并和程序一起给每个其
    他的程序接受者一份许可证的副本，你就可用任何媒体复制和发布你
    收到的原始程序的源代码。你也可以为转让副本的实际行动收取一定
    费用，但必须事先得到的同意。                                
二. 你可以修改本开源软件的一个或几个副本或程序的任何部分，以此形
    成基于程序的作品。只要你同时满足下面的所有条件，你就可以按前
    面第一款的要求复制和发布这一经过修改的程序或作品。          
  1.你必须在修改的文件中附有明确说明：你修改了这一文件及具体的修
    改日期。                                                    
  2.你必须使你发布或出版的作品（它包含程序的全部或一部分，或包含
    由程序的全部或部分衍生的作品）允许第三方作为整体按许可证条款
    免费使用。                                                  
  3.如果修改的程序在运行时以交互方式读取命令，你必须使它在开始进
    入常规的交互使用方式时打印或显示声明: 包括适当的版权声明和没
    有担保的声明（或者你提供担保的声明）；用户可以按此许可证条款
    重新发布程序的说明；并告诉用户如何看到这一许可证的副本。（例
    外的情况: 如果原始程序以交互方式工作，它并不打印这样的声明，
    你的基于程序的作品也就不用打印声明。                        
三. 只要你遵循一、二条款规定，您就可以自由使用并传播本源代码，但
    必须原封不动地保留原作者信息。                              
================================================================
**************************************************************|;

;;;=============================================================
;;; FFT（快速傅里叶变换）和IFFT（FFT逆变换）代码的终极实现      
;;; 参数: S=1为FFT,lst为系数列表; S=-1为IFFT,lst为要还原的复数表
;;; 返回: FFT返回复数表，IFFT返回多项式系数表                   
;;; 说明: 设多项式P系数为A0,A1,...,An-1,指数从低到高            
;;;-------------------------------------------------------------
;;; A little test 小测试:                                       
;;; (FFT 1 '(1 -6 2 4))                                         
;;; => ((1.0 0.0) (-1.0 -10.0) (5.0 0.0) (-1.0 10.0))           
;;; (FFT -1 '((1.0 0.0) (-1.0 -10.0) (5.0 0.0) (-1.0 10.0)))    
;;; => (1.0 -6.0 2.0 4.0)                                       
;;; 可见很好地还原了系数。                                      
;;; 代码稍加修改可进行复系数的FFT和IFFT变换。                   
;;;=============================================================
(defun FFT (s lst / len new)
  (if (and lst (listp lst))
    (progn
      ;;把实系数转成复系数 
      (setq lst	(mapcar (function (lambda (x) (if (listp x) x (list x 0)))) lst))
      (setq len (length lst))
      (setq new (/ (log len) (log 2)))
      ;;如果列表长度不满足2^N，则补0
      (if (not (equal (fix new) new 1e-8))
	(progn
	  (setq new (expt 2 (1+ (fix new))))
	  (setq lst (reverse lst))
	  (repeat (- new len)
	    (setq lst (cons '(0 0) lst))
	  )
	  (setq lst (reverse lst))
	  (setq len new)
	)
      )
      ;;S为1进行FFT，否则进行IFFT并除以新的表长。
      (if (> s 0)
	(RFFT 1 lst)
	(mapcar
	  (function (lambda (x) (/ (car x) len)))
	  (RFFT -1 lst)
	)
      )
    )
  )
)

;;;=============================================================
;;; 获取偶数项                                                  
;;;=============================================================
(defun evens (f)
  (if f
    (cons (car f) (evens (cddr f)))
  )
)

;;;=============================================================
;;; 获取奇数项                                                  
;;;=============================================================
(defun odds (f)
  (if f
    (cons (cadr f) (odds (cddr f)))
  )
)

;;;=============================================================
;;; 求w(利用欧拉公式求系数)                                     
;;;=============================================================
(defun phase (s k n / x)
  ;;(exp (/ (* 0+2i s k 3.1415926535 ) N) )
  (if (> s 0)
    (setq x (/ (* (- pi) k) N))
    (setq x (/ (* PI k) N))
  )
  (list (cos x) (sin x))
)

;;;=============================================================
;;; 求每一项乘以系数（即对复数旋转）                            
;;;=============================================================
(defun rotate (s k N f / )
  (if f
    (cons
      (CMP::MUL (phase s k N) (car f))
      (rotate s (1+ k) N (cdr f))
    )
  )
)

;;;=============================================================
;;; 此处修改仅仅是为了减少递归深度                              
;;;=============================================================
(defun PFFT (s f / e o)
  (if (= 2 (length f))
    (list
      (apply 'CMP::ADD f)
      (apply 'CMP::SUB f)
    )
    (combine s (PFFT s (evens f)) (PFFT s (odds f)))
  )
)

;;;=============================================================
;;; With these preliminaries PFFT is simple                     
;;; 此段为原来方式(the original way)                            
;;;=============================================================
(defun PFFT1 (s f / e o)
  (if (= 1 (length f))
    f
    (combine s (PFFT1 s (evens f)) (PFFT1 s (odds f)))
  )
)

(defun phase2 (s k n / x)
  (if (> s 0)
    (setq x (/ (* -6.283185307179586476925286766559 k) N))
    (setq x (/ (* 6.283185307179586476925286766559 k) N))
  )
  (list (cos x) (sin x))
)

(defun RFFT (s f / E K N O)
  (setq N (length f))
  (if (= 1 N)
    F
    (progn
      (setq k 0)
      (mapcar 
	(function
	  (lambda (x y / w)
	    (setq w (phase2 s k n))
	    (setq y (CMP::MUL w y))
	    (setq e (cons (CMP::ADD x y) e))
	    (setq o (cons (CMP::SUB x y) o))
	    (setq k (1+ k))
	  )
	)
        (RFFT s (evens f))
	(RFFT s (odds f))
      )
      (append (reverse e) (reverse o))
    )
  )
)

;;;=============================================================
;;; 合并奇偶两部分                                              
;;;=============================================================
(defun combine (s ev od)
  (plusminus ev (rotate s 0 (length od) od))
)

;;;=============================================================
;;; 奇偶两部分相加减                                            
;;;=============================================================
(defun plusminus (a b)
  (append (mapcar 'CMP::ADD a b) (mapcar 'CMP::SUB a b))
)

;;;=============================================================
;;; 复数相加                                                    
;;;=============================================================
(defun CMP::ADD (z1 z2)
  (mapcar '+ z1 z2)
)

;;;=============================================================
;;; 复数相减                                                    
;;;=============================================================
(defun CMP::SUB (z1 z2)
  (mapcar '- z1 z2)
)

;;;=============================================================
;;; 复数相乘                                                    
;;;=============================================================
(defun CMP::MUL (z1 z2)
  (list
    (- (* (car z1) (car z2)) (* (cadr z1) (cadr z2)))
    (+ (* (car z1) (cadr z2)) (* (car z2) (cadr z1)))
  )
)

;;;=============================================================
;;; 复数乘以一个系数                                            
;;;=============================================================
(defun CMP::SCL (z x)
  (list (* x (car z) ) (* x (cadr z)))
)